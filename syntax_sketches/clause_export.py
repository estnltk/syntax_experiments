from typing import Dict


def export_cleaned_clause(clause: Dict[str, list]) -> str:
    """
    Exports a cleaned clause into the CoNLL-U format. This can be used to create various data sets.
    The function assumes that the input is generated by the function clean_clause and that there is only one root node.
    Returns a properly formatted table where each token is on the separate line and upos and xpos fields are the same.
    """

    assert len(clause['root_loc']) == 1, 'There can be only one root in a clause'
    assert len(clause['ids']) == len(clause['wordforms']) == len(clause['lemmas']), 'Fields must be aligned'
    assert len(clause['ids']) == len(clause['postags']) == len(clause['features']), 'Fields must be aligned'
    assert len(clause['ids']) == len(clause['deprels']) == len(clause['heads']), 'Fields must be aligned'

    # As standard ids will be assigned to all tokens in a clause we need update heads
    head_map = {clause_id: idx + 1 for idx, clause_id in enumerate(clause['ids'])}
    
    result = []
    row_template = '{id}\t{wordform}\t{lemma}\t{postag}\t{postag}\t{features}\t{head}\t{deprel}\t_\t_'
    for i in range(len(clause['ids'])):

        head = head_map.get(clause['heads'][i], 0)
        deprel = clause['deprels'][i] if head != 0 else 'root'

        if clause['features'][i]:
            features = '|'.join([key + '=' + value for key, value in clause['features'][i].items()])
        else:
            features = '_'

        result.append(row_template.format(
            id=i + 1,
            wordform=clause['wordforms'][i],
            lemma=clause['lemmas'][i],
            postag=clause['postags'][i],
            features=features,
            head=head,
            deprel=deprel))

    return '\n'.join(result)
