import os, os.path
from typing import List

# Mapping from conllu field name to key name in output dictionary
conllu2dictkey = \
     [('id', 'ids'), 
      ('wordform', 'wordforms'),
      ('lemma', 'lemmas'),
      ('upos', None),
      ('xpos', 'postags'),
      ('features', 'features'),
      ('head', 'heads'),
      ('deprel', 'deprels'),
      ('deps', None),
      ('misc', None)]
 

def import_clauses(input_file: str, as_dicts:bool=False) -> List[str]:
    """
    Imports all clauses from a CoNLL-U format file. 
    
    By default, returns a list of CoNLL-U strings, each corresponding 
    to a clause. If as_dicts==True, then returns a list of dicts, 
    each dict containing CoNLL features extracted from a single clause 
    (dict keys: ids, postags, deprels, heads, root_loc, wordforms, 
    lemmas, features).
    
    CoNLL-U strings output format is used in filtering/removing clauses, 
    dicts output format is a basis for creating syntax sketches for 
    clauses.
    
    The function assumes that clauses in the input file have been 
    generated by the function export_cleaned_clause.
    """
    assert os.path.exists( input_file ), f'Non-existent input conllu file: {input_file}'
    clause_dicts = []
    clause_strings = []
    with open(input_file, 'r', encoding='utf-8') as in_f:
        clause_started = False
        current_clause = []
        current_clause_dict = dict(ids=[], postags=[], deprels=[], 
                                   heads=[], root_loc=[], wordforms=[], 
                                   lemmas=[], features=[])
        for line in in_f:
            if len(line.rstrip()) > 0:
                if line[0].isnumeric():
                    number_of_fields = len(line.split('\t'))
                    assert number_of_fields == len(conllu2dictkey), \
                        f'Unexpected number of fields ({number_of_fields}) on conllu line: {line!r}'
                    # line corresponds to a word's analysis
                    if not as_dicts:
                        # extract only CoNLL line
                        current_clause.append( line.rstrip() )
                    else:
                        # extract CoNLL field values to dict
                        parts = line.split('\t')
                        for field_id, (conllu_field, dict_key) in enumerate(conllu2dictkey):
                            if dict_key is not None:
                                value = parts[field_id]
                                current_clause_dict[dict_key].append(value)
                    clause_started = True
                else:
                    if not line.startswith('#'):
                        raise ValueError(f'Unexpected conllu line: {line!r}')
            else:
                if clause_started:
                    # end of a clause
                    if not as_dicts:
                        # Save clause CoNLL lines
                        clause_strings.append('\n'.join(current_clause))
                        current_clause = []
                    else:
                        # Find indices of root nodes
                        ids = current_clause_dict['ids']
                        heads = current_clause_dict['heads']
                        root_locations = [i for i, head in enumerate(heads) if head not in ids]
                        current_clause_dict['root_loc'] = root_locations
                        # Save clause dict
                        clause_dicts.append(current_clause_dict)
                        current_clause_dict = dict(ids=[], postags=[], deprels=[], 
                                                   heads=[], root_loc=[], wordforms=[], 
                                                   lemmas=[], features=[])
                    clause_started = False
    # add the last remaining clause
    if clause_started:
        if not as_dicts:
            # Save clause CoNLL lines
            clause_strings.append('\n'.join(current_clause))
        else:
            # Find indices of root nodes
            ids = current_clause_dict['ids']
            heads = current_clause_dict['heads']
            root_locations = [i for i, head in enumerate(heads) if head not in ids]
            current_clause_dict['root_loc'] = root_locations
            # Save clause dict
            clause_dicts.append(current_clause_dict)
    return clause_strings if not as_dicts else clause_dicts

